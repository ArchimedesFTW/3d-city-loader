//! Defines systems and functions for loading external data using queries.
use wasm_bindgen::prelude::*;

use crate::common::{
    spawn_compute_task, AppError, AsyncComputation, DataFormat,
    handle_compute_tasks, StatusEvent,
};
use crate::data::geography::{convert_osm_json, GeoData};
use crate::data::query::DataQuery;
use crate::earth::GeoDataEvent;

use bevy::prelude::*;

use bevy_mod_reqwest::{BevyReqwest, Listener, On, ReqResponse};

use std::sync::Arc;

/// An event for querying and loading external data.
#[derive(Clone, Debug, Event)]
pub struct DataQueryEvent {
    pub query: DataQuery,
}

const OVERPASS_URL: &'static str = "https://overpass-api.de/api/interpreter";

/// A system that reads geographic data load requests, which are normally
/// generated by the UI when the user enters a query.
/// 
/// It will send a `GeoDataEvent` if new geographic data has been obtained and
/// is ready to be loaded.
/// 
/// # See also
/// [Overpass API](https://wiki.openstreetmap.org/wiki/Overpass_APIs)
pub fn update_data_queries(
    mut commands: Commands,
    mut client: BevyReqwest,
    mut data_load_events: EventReader<DataQueryEvent>,
) {
    for event in data_load_events.read() {
        match &event.query {
            DataQuery::OverpassQL { value } => {
                let request = client.get(OVERPASS_URL)
                    .query(&[("data", value)])
                    .build()
                    .unwrap_throw();
                client.send(request, On::run(overpass_listener));
            },
            DataQuery::File { format, file_path } => {
                let file_path_clone = file_path.clone();
                let format_clone = format.clone();
                spawn_compute_task(&mut commands, async move {
                    let file_contents = match std::fs::read_to_string(&file_path_clone) {
                        Ok(value) => value,
                        Err(error) => return Err(
                            AppError::from_io_error(error, &file_path_clone),
                        ),
                    };
                    match format_clone {
                        DataFormat::GeoJson => {
                            todo!();
                        },
                        DataFormat::OsmJson => match serde_json::from_str(&file_contents) {
                            Ok(json) => convert_osm_json(json),
                            Err(error) => Err(
                                AppError::from_json_error(error, DataFormat::OsmJson),
                            ),
                        },
                    }
                });
            },
        }
    }
}

fn overpass_listener(
    req: Listener<ReqResponse>,
    mut commands: Commands,
    mut status_events: EventWriter<StatusEvent>,
) {
    let body = match req.as_string() {
        Ok(body) => body,
        Err(error) => {
            status_events.send(StatusEvent::Error(AppError::Io {
                message: error.to_string(),
                status: Some(req.status()),
                url: None, // can't get that from the request :/
            }));
            return;
        },
    };

    status_events.send(StatusEvent::Update(
        "Successfully received data from Overpass, now importing...".to_owned(),
    ));

    // Server does not allow to save the data as folder doesn't exist and it's not allowed to create it
    // std::fs::write("./geocache/last.json", &body).unwrap_throw();

    spawn_compute_task(&mut commands, async move {
        match serde_json::from_str(&body) {
            Ok(json) => convert_osm_json(json),
            Err(error) => Err(
                AppError::from_json_error(error, DataFormat::OsmJson),
            ),
        }
    });
}

/// A system that polls data query tasks that are not yet fulfilled.
pub fn update_query_tasks(
    mut commands: Commands,
    query: Query<(Entity, &mut AsyncComputation<Result<GeoData, AppError>>)>,
    mut geo_data_events: EventWriter<GeoDataEvent>,
    mut status_events: EventWriter<StatusEvent>,
) {
    handle_compute_tasks(&mut commands, query, move |_, data| {
        match data {
            Ok(value) => {
                if value.is_empty() {
                    status_events.send(StatusEvent::Error(AppError::MissingData {
                        message: "no geographic data was found".to_owned(),
                    }));
                } else {
                    status_events.send(StatusEvent::Update(
                        "Successfully imported data, now adding to the world...".to_owned(),
                    ));
                    geo_data_events.send(GeoDataEvent { data: Arc::new(value) });
                }
            },
            Err(error) => {
                status_events.send(StatusEvent::Error(error));
            },
        }
    });
}
